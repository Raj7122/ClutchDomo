import { NextRequest, NextResponse } from 'next/server';
import { TavusClient, generateTavusSystemPrompt } from '@/lib/tavusClient';
import { createServerSupabaseClient } from '@/lib/serverSupabaseClient';
import { SupabaseClient } from '@supabase/supabase-js';

interface TavusSessionData {
  id?: string;
  conversation_id?: string;
  replica_id?: string;
  status?: string;
  conversation_url?: string;
  demo_id?: string;
  agent_id?: string;
  created_at?: string;
  updated_at?: string;
  is_active?: boolean;
  is_mock?: boolean;
  metadata?: any;
}

interface DemoData {
  title: string;
  videos: any[];
  ctaLink?: string;
  persona_id?: string;
  replica_id?: string;
  context?: string;
  max_call_duration?: number;
  enable_recording?: boolean;
  knowledgeBase: string;
}

interface RequestBody {
  demoId: string;
  demoData: DemoData;
}

/**
 * Tavus Session API with Enterprise-Grade Concurrency Control
 *
 * This implementation uses multiple layers of race condition prevention:
 * 1. In-memory mutex locks to prevent parallel processing of same demo ID
 * 2. Request deduplication cache to prevent duplicate API calls
 * 3. Database checks for existing sessions before creating new ones
 * 4. Double-check after lock acquisition to handle race conditions
 */

// Strong concurrency control using process-wide locks
const activeLocks = new Map<string, boolean>();

// Request deduplication cache with TTL
const sessionCache = new Map<string, {timestamp: number, data: any}>();
const CACHE_TTL_MS = 10000; // 10 second deduplication window

// Helper function to generate consistent keys
const getSessionCacheKey = (demoId: string): string => `session-${demoId}`;
const getLockKey = (demoId: string): string => `lock-${demoId}`;

// Generate a realistic-looking conversation ID for fallbacks
const generateRealisticId = (): string => {
  const chars = '0123456789abcdef';
  let result = '';
  for (let i = 0; i < 16; i++) {
    result += chars.charAt(Math.floor(Math.random() * chars.length));
  }
  return result;
};

// Mutex lock implementation
const acquireLock = (demoId: string): boolean => {
  const lockKey = getLockKey(demoId);
  if (activeLocks.has(lockKey)) {
    console.log(`CONCURRENCY: Lock exists for demo ${demoId}, preventing concurrent creation`);
    return false;
  }
  activeLocks.set(lockKey, true);
  console.log(`CONCURRENCY: Lock acquired for demo ${demoId}`);
  return true;
};

const releaseLock = (demoId: string): void => {
  const lockKey = getLockKey(demoId);
  if (activeLocks.has(lockKey)) {
    activeLocks.delete(lockKey);
    console.log(`CONCURRENCY: Lock released for demo ${demoId}`);
  }
};

export async function POST(request: NextRequest) {
  console.log('=== Create Tavus Session API Started ===');
  let demoId: string | null = null;
  let lockAcquired = false;
  
  try {
    // Parse request body
    const requestBody = await request.json() as RequestBody;
    const { demoId: parsedDemoId, demoData } = requestBody;
    demoId = parsedDemoId;

    // Validate required parameters
    if (!demoId || !demoData || !demoData.title || !demoData.videos || !demoData.knowledgeBase) {
      return NextResponse.json({ 
        error: 'Missing required parameters',
        details: 'demoId, title, videos and knowledgeBase are required'
      }, { status: 400 });
    }

    console.log('Creating Tavus session for demo:', demoId);
    
    // First check database for existing active session for this demo
    const supabase = createServerSupabaseClient();
    const { data: existingSession, error: dbError } = await supabase
      .from('tavus_sessions')
      .select('*')
      .eq('demo_id', demoId)
      .eq('is_active', true)
      .order('created_at', { ascending: false })
      .limit(1);
    
    if (dbError) {
      console.error('Database query error:', dbError);
    }
    
    if (existingSession && existingSession.length > 0) {
      console.log('Found existing active session in database:', existingSession[0].conversation_id);
      const conversationData = existingSession[0].conversation_data || {};
      
      // Return the existing session information
      return NextResponse.json({
        success: true,
        conversation_id: existingSession[0].conversation_id,
        conversation_url: conversationData.conversation_url,
        message: 'Using existing active session from database'
      });
    }
    
    // Check cache for recent session for this demo to prevent duplicates
    const cachedSession = sessionCache.get(getSessionCacheKey(demoId));
    
    if (cachedSession && (Date.now() - cachedSession.timestamp < CACHE_TTL_MS)) {
      console.log('Using cached session from recent request:', cachedSession.data.conversation_id);
      return NextResponse.json(cachedSession.data);
    }
    
    // Try to acquire mutex lock for this demo ID - CRITICAL SECTION
    if (!acquireLock(demoId)) {
      console.log('Another request is already creating a session for this demo');
      return NextResponse.json({
        success: false,
        error: 'Session creation already in progress',
        message: 'Please wait for the existing request to complete'
      }, { status: 409 }); // 409 Conflict
    }
    lockAcquired = true;

    // After acquiring lock, recheck database in case a session was created
    // between our first check and lock acquisition (race condition protection)
    const { data: doubleCheckSession } = await supabase
      .from('tavus_sessions')
      .select('*')
      .eq('demo_id', demoId)
      .eq('is_active', true)
      .order('created_at', { ascending: false })
      .limit(1);
    
    if (doubleCheckSession && doubleCheckSession.length > 0) {
      console.log('After lock: found session that was just created:', doubleCheckSession[0].conversation_id);
      const conversationData = doubleCheckSession[0].conversation_data || {};
      
      // Release lock before returning
      releaseLock(demoId);
      lockAcquired = false;
      
      // Return the existing session information
      return NextResponse.json({
        success: true,
        conversation_id: doubleCheckSession[0].conversation_id,
        conversation_url: conversationData.conversation_url,
        message: 'Using just-created session (race condition avoided)'
      });
    }

    // Initialize Tavus client
    const tavus = new TavusClient();

    // Step 1: Create a new Tavus conversation
    console.log('Creating new Tavus conversation');
    
    try {
      // Create Tavus conversation session
      const defaultReplicaId = 'r_0b0e1'; // Default replica ID if none provided
      
      const session = await tavus.createConversation(
        demoData.replica_id || defaultReplicaId, 
        {
          demo_id: demoId,
          persona_id: demoData.persona_id,
          context: demoData.context || 'product_demo',
          demo_title: demoData.title,
          video_count: demoData.videos?.length || 0,
          has_cta: !!demoData.ctaLink,
          created_at: new Date().toISOString()
        }
      );

      console.log('Tavus session created successfully:', session.conversation_id);

      // Store session in database for analytics
      try {
        await supabase
          .from('tavus_sessions')
          .insert({
            demo_id: demoId,
            conversation_id: session.conversation_id,
            is_active: true,
            llm_model: 'tavus-gpt-4o',
            system_prompt: generateTavusSystemPrompt(demoData),
            conversation_data: {
              demo_title: demoData.title,
              video_count: demoData.videos?.length || 0,
              has_cta: !!demoData.ctaLink,
              replica_id: session.replica_id,
              conversation_url: session.conversation_url
            },
            created_at: new Date().toISOString()
          });
        
        console.log('Session stored in database');
      } catch (dbError) {
        console.warn('Failed to store session in database (non-critical):', dbError);
      }

      // Prepare response data
      const responseData = {
        success: true,
        conversation_id: session.conversation_id,
        replica_id: session.replica_id,
        status: session.status,
        conversation_url: session.conversation_url
      };
      
      // Cache the successful response to prevent duplicate requests
      sessionCache.set(getSessionCacheKey(demoId), {
        data: responseData,
        timestamp: Date.now()
      });
      
      // Release lock before returning
      releaseLock(demoId);
      lockAcquired = false;
      
      return NextResponse.json(responseData);
      
    } catch (tavusError) {
      console.error('Error creating Tavus conversation:', tavusError);
      
      // Generate fallback mock session if Tavus API fails
      console.log('Creating fallback mock session as Tavus API failed');
      const mockConversationId = generateRealisticId();
      const mockSession = {
        success: true,
        conversation_id: mockConversationId,
        replica_id: 'mock-replica',
        status: 'active',
        conversation_url: `https://tavus.daily.co/${mockConversationId}?mock=true`,
        is_mock: true
      };
      
      // Store mock session in database
      try {
        await supabase
          .from('tavus_sessions')
          .insert({
            demo_id: demoId,
            conversation_id: mockSession.conversation_id,
            is_active: true,
            is_mock: true,
            llm_model: 'mock-gpt-4o',
            system_prompt: generateTavusSystemPrompt(demoData),
            conversation_data: {
              demo_title: demoData.title,
              video_count: demoData.videos?.length || 0,
              has_cta: !!demoData.ctaLink,
              replica_id: mockSession.replica_id,
              conversation_url: mockSession.conversation_url,
              is_mock: true
            },
            created_at: new Date().toISOString()
          });
          
        console.log('Mock session stored in database');
      } catch (dbError) {
        console.warn('Failed to store mock session in database:', dbError);
      }
      
      // Release lock before returning
      releaseLock(demoId);
      lockAcquired = false;
      
      return NextResponse.json({
        ...mockSession,
        warning: 'Using mock session due to Tavus API issues',
        original_error: tavusError instanceof Error ? tavusError.message : 'Unknown error'
      });
    }

  } catch (error) {
    console.error('=== Create Tavus Session API Error ===');
    console.error('Error details:', error);
    
    // If we have acquired a lock, release it
    if (demoId && lockAcquired) {
      releaseLock(demoId);
    }
    
    // Generate mock conversation ID for error fallback
    const fallbackId = generateRealisticId();
    const fallbackSession = {
      conversation_id: fallbackId,
      replica_id: 'error-fallback',
      status: 'active',
      conversation_url: `https://tavus.daily.co/${fallbackId}?error=true`,
      error_fallback: true
    };
    
    return NextResponse.json({
      success: true,
      ...fallbackSession,
      warning: 'Using error fallback session due to server error',
      original_error: error instanceof Error ? error.message : 'Unknown error'
    });
  }
}

// Handle preflight requests for CORS
export async function OPTIONS(request: NextRequest) {
  return new NextResponse(null, {
    status: 200,
    headers: {
      'Access-Control-Allow-Origin': '*',
      'Access-Control-Allow-Methods': 'POST, OPTIONS',
      'Access-Control-Allow-Headers': 'Content-Type, Authorization',
    },
  });
}
